# SkillChain å¼€å‘æ–‡æ¡£

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®å®šä½
SkillChainæ˜¯ä¸€ä¸ªé©å‘½æ€§çš„å»ä¸­å¿ƒåŒ–AIæŠ€èƒ½å¸‚åœºå¹³å°ï¼Œè®©å¼€å‘è€…ã€å›¢é˜Ÿå’Œä¸ªäººèƒ½å¤Ÿåˆ›å»ºã€æ‰“åŒ…ã€ä¸Šé“¾å¹¶äº¤æ˜“AI Skillsï¼ˆæŠ€èƒ½åŒ…ï¼‰ã€‚æ¯ä¸ªSkilléƒ½æ˜¯åŒ…å«æŒ‡ä»¤ã€é…ç½®å’Œèµ„æºçš„ç»“æ„åŒ–æ–‡ä»¶å¤¹ï¼Œèƒ½è®©AIæ¨¡å‹ï¼ˆå¦‚Claudeã€GPTç­‰ï¼‰å¿«é€Ÿæˆä¸ºç‰¹å®šä»»åŠ¡çš„ä¸“å®¶ã€‚

### 1.2 æ ¸å¿ƒä»·å€¼ä¸»å¼ 
- **æŠ€èƒ½èµ„äº§åŒ–**ï¼šå°†AIæŠ€èƒ½è½¬åŒ–ä¸ºå¯äº¤æ˜“çš„é“¾ä¸Šèµ„äº§ï¼ˆNFT/License Tokenï¼‰
- **æ”¶ç›Šåˆ†é…**ï¼šé€šè¿‡æ™ºèƒ½åˆçº¦å®ç°è‡ªåŠ¨åŒ–çš„æ”¶ç›Šåˆ†é…ä¸ç‰ˆç¨æœºåˆ¶
- **ä¿¡èª‰ç§¯ç´¯**ï¼šå»ºç«‹å»ä¸­å¿ƒåŒ–çš„æŠ€èƒ½è´¨é‡è¯„ä»·å’Œä¿¡èª‰ä½“ç³»
- **å¯ç»„åˆæ€§**ï¼šæ”¯æŒæŠ€èƒ½çš„æ¨¡å—åŒ–ç»„åˆå’Œå¤ç”¨
- **è·¨å¹³å°å…¼å®¹**ï¼šåŸºäºæ ‡å‡†åŒ–æ ¼å¼ï¼Œæ”¯æŒå¤šç§AIæ¨¡å‹

### 1.3 å¸‚åœºæœºé‡
åŸºäºæœ€æ–°Claude Skillså‘å±•è¶‹åŠ¿<mcurl name="Anthropic Skills" url="https://www.anthropic.com/news/skills"></mcurl>ï¼ŒAIæŠ€èƒ½å¸‚åœºæ­£ç»å†å¿«é€Ÿå¢é•¿ï¼š
- Claude Skillsé‡‡ç”¨æ¸è¿›å¼æŠ«éœ²æ¶æ„ï¼Œæ”¯æŒæŠ€èƒ½åŠ¨æ€åŠ è½½
- ä¼ä¸šçº§åº”ç”¨æ˜¾ç¤º8å€ç”Ÿäº§åŠ›æå‡
- æŠ€èƒ½ç»„åˆæ€§å’Œå¯ç§»æ¤æ€§æˆä¸ºå…³é”®ä¼˜åŠ¿

## 2. æŠ€æœ¯æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„
```mermaid
graph TD
    A[ç”¨æˆ·ç•Œé¢] --> B[NextJSå‰ç«¯]
    B --> C[Supabaseåç«¯]
    B --> D[æ™ºèƒ½åˆçº¦äº¤äº’]
    C --> E[IPFSå­˜å‚¨]
    D --> F[ä»¥å¤ªåŠç½‘ç»œ]
    E --> G[æŠ€èƒ½å…ƒæ•°æ®]
    E --> H[æŠ€èƒ½èµ„æºæ–‡ä»¶]
    
    subgraph "é“¾ä¸Šç»„ä»¶"
        F
        I[NFTåˆçº¦]
        J[è®¸å¯è¯åˆçº¦]
        K[æ”¶ç›Šåˆ†é…åˆçº¦]
    end
    
    subgraph "é“¾ä¸‹ç»„ä»¶"
        B
        C
        E
        L[AIæŠ€èƒ½è§£æå™¨]
    end
```

### 2.2 æŠ€æœ¯æ ˆé€‰æ‹©
- **å‰ç«¯**ï¼šNextJS + TypeScript + Tailwind CSS + daisyUI
- **åç«¯**ï¼šSupabaseï¼ˆè®¤è¯+æ•°æ®åº“+å­˜å‚¨ï¼‰
- **åŒºå—é“¾**ï¼šEthereum + Scaffold-ETH 2æ¡†æ¶
- **å­˜å‚¨**ï¼šIPFS + Filecoinï¼ˆæŠ€èƒ½æ–‡ä»¶ï¼‰
- **AIé›†æˆ**ï¼šClaude API + OpenAI API

### 2.3 æ ¸å¿ƒç»„ä»¶
```mermaid
graph TD
    A[SkillChain Core]
    A --> B[Skill Manager]
    A --> C[Marketplace Engine]
    A --> D[License Manager]
    A --> E[Revenue Distributor]
    A --> F[Reputation System]
    
    B --> B1[Skill Parser]
    B --> B2[Skill Validator]
    B --> B3[Skill Packager]
    
    C --> C1[Listing Service]
    C --> C2[Search Engine]
    C --> C3[Price Oracle]
    
    D --> D1[License NFT]
    D --> D2[Usage Tracker]
    D --> D3[Access Control]
    
    E --> E1[Payment Splitter]
    E --> E2[Royalty Engine]
    E --> E3[Staking Rewards]
    
    F --> F1[Review System]
    F --> F2[Quality Metrics]
    F --> F3[Trust Score]
```

## 3. AI Skillsç»“æ„å’Œæ ‡å‡†åŒ–æ ¼å¼

### 3.1 æŠ€èƒ½åŒ…ç»“æ„
åŸºäºClaude Skillsæœ€ä½³å®è·µ<mcurl name="Agent Skills Engineering" url="https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills"></mcurl>ï¼Œé‡‡ç”¨æ ‡å‡†åŒ–æ–‡ä»¶å¤¹ç»“æ„ï¼š

```
skill-package/
â”œâ”€â”€ SKILL.md              # æ ¸å¿ƒæŠ€èƒ½å®šä¹‰æ–‡ä»¶
â”œâ”€â”€ manifest.json         # æŠ€èƒ½å…ƒæ•°æ®
â”œâ”€â”€ instructions/         # æŒ‡ä»¤æ–‡ä»¶å¤¹
â”‚   â”œâ”€â”€ system-prompt.md
â”‚   â”œâ”€â”€ examples.md
â”‚   â””â”€â”€ best-practices.md
â”œâ”€â”€ resources/           # èµ„æºæ–‡ä»¶å¤¹
â”‚   â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ datasets/
â”‚   â””â”€â”€ references/
â”œâ”€â”€ scripts/             # å¯æ‰§è¡Œè„šæœ¬
â”‚   â”œâ”€â”€ preprocess.py
â”‚   â””â”€â”€ postprocess.js
â”œâ”€â”€ tests/               # æµ‹è¯•ç”¨ä¾‹
â””â”€â”€ config.yaml          # é…ç½®æ–‡ä»¶
```

### 3.2 SKILL.mdæ ¼å¼
é‡‡ç”¨YAML Frontmatteræ ‡å‡†ï¼š

```yaml
---
name: "Excelæ•°æ®åˆ†æä¸“å®¶"
description: "ä¸“ä¸šçš„Excelæ•°æ®åˆ†æå’Œå¯è§†åŒ–æŠ€èƒ½åŒ…"
version: "1.0.0"
author: "DataPro Team"
category: "data-analysis"
tags: ["excel", "data-viz", "analytics"]
ai_models: ["claude", "gpt-4"]
pricing:
  type: "subscription"
  price: 0.1
  currency: "ETH"
license: "commercial"
difficulty: "intermediate"
estimated_time: "30-60åˆ†é’Ÿ"
---

# Excelæ•°æ®åˆ†æä¸“å®¶

## æŠ€èƒ½æ¦‚è¿°
æ­¤æŠ€èƒ½åŒ…è®©AIæˆä¸ºExcelæ•°æ®åˆ†æä¸“å®¶ï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„æ•°æ®é›†ã€åˆ›å»ºé«˜çº§å›¾è¡¨ã€æ‰§è¡Œç»Ÿè®¡åˆ†æç­‰ã€‚

## æ ¸å¿ƒèƒ½åŠ›
- æ•°æ®æ¸…æ´—å’Œé¢„å¤„ç†
- é«˜çº§å…¬å¼å’Œå‡½æ•°åº”ç”¨
- æ•°æ®é€è§†è¡¨åˆ›å»º
- å›¾è¡¨å’Œä»ªè¡¨æ¿è®¾è®¡
- ç»Ÿè®¡åˆ†æ

## ä½¿ç”¨åœºæ™¯
- å•†ä¸šæŠ¥å‘Šåˆ¶ä½œ
- é”€å”®æ•°æ®åˆ†æ
- è´¢åŠ¡æŠ¥è¡¨ç”Ÿæˆ
- å¸‚åœºè¶‹åŠ¿åˆ†æ
```

### 3.3 æŠ€èƒ½å…ƒæ•°æ®æ ‡å‡†
```json
{
  "id": "skill_unique_identifier",
  "name": "æŠ€èƒ½åç§°",
  "description": "æŠ€èƒ½æè¿°",
  "version": "1.0.0",
  "author": {
    "name": "ä½œè€…åç§°",
    "address": "0x...",
    "reputation": 95
  },
  "category": "æŠ€èƒ½åˆ†ç±»",
  "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"],
  "ai_compatibility": {
    "claude": "3.5+",
    "gpt": "4.0+",
    "gemini": "1.5+"
  },
  "requirements": {
    "context_window": "8k",
    "tools": ["code_execution", "file_access"],
    "skills": ["åŸºç¡€ç¼–ç¨‹", "æ•°æ®åˆ†æ"]
  },
  "pricing": {
    "model": "subscription",
    "price": 0.1,
    "currency": "ETH",
    "billing_cycle": "monthly"
  },
  "quality_metrics": {
    "success_rate": 0.95,
    "user_rating": 4.8,
    "usage_count": 1250
  },
  "dependencies": [],
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-15T00:00:00Z"
}
```

## 4. æ™ºèƒ½åˆçº¦è®¾è®¡

### 4.1 åˆçº¦æ¶æ„
```mermaid
graph TD
    A[SkillChain Core Contract]
    A --> B[SkillNFT Contract]
    A --> C[LicenseToken Contract]
    A --> D[Marketplace Contract]
    A --> E[RevenueDistributor Contract]
    A --> F[ReputationManager Contract]
    
    B --> B1[ERC721æ ‡å‡†]
    B --> B2[æŠ€èƒ½å…ƒæ•°æ®å­˜å‚¨]
    B --> B3[ç‰ˆç¨æœºåˆ¶]
    
    C --> C1[ERC1155æ ‡å‡†]
    C --> C2[è®¸å¯è¯ç®¡ç†]
    C --> C3[ä½¿ç”¨æ¬¡æ•°è·Ÿè¸ª]
    
    D --> D1[æŒ‚å•ç³»ç»Ÿ]
    D --> D2[æ‹å–æœºåˆ¶]
    D --> D3[ä»·æ ¼é¢„è¨€æœº]
    
    E --> E1[è‡ªåŠ¨åˆ†è´¦]
    E --> E2[è´¨æŠ¼å¥–åŠ±]
    E --> E3[å¹³å°è´¹ç”¨]
    
    F --> F1[è¯„ä»·ç³»ç»Ÿ]
    F --> F2[ä¿¡èª‰åˆ†æ•°]
    F --> F3[æ²»ç†æƒé‡]
```

### 4.2 SkillNFTåˆçº¦
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SkillNFT is ERC721, ERC721URIStorage, ERC721Royalty, Ownable {
    uint256 private _tokenIdCounter;
    
    struct SkillMetadata {
        string skillId;
        string name;
        string category;
        string[] tags;
        address creator;
        uint256 createdAt;
        uint256 price;
        string currency;
        uint256 royaltyPercentage;
        bool isActive;
    }
    
    mapping(uint256 => SkillMetadata) public skillMetadata;
    mapping(string => uint256) public skillIdToTokenId;
    mapping(address => uint256[]) public creatorSkills;
    
    event SkillCreated(uint256 indexed tokenId, string skillId, address creator);
    event SkillPriceUpdated(uint256 indexed tokenId, uint256 newPrice);
    
    constructor() ERC721("SkillChain Skill NFT", "SKILL") {}
    
    function createSkill(
        string memory skillId,
        string memory name,
        string memory category,
        string[] memory tags,
        string memory tokenURI,
        uint256 price,
        string memory currency,
        uint256 royaltyPercentage
    ) public returns (uint256) {
        require(skillIdToTokenId[skillId] == 0, "Skill ID already exists");
        require(royaltyPercentage <= 10000, "Royalty too high"); // 10000 = 100%
        
        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter++;
        
        _safeMint(msg.sender, tokenId);
        _setTokenURI(tokenId, tokenURI);
        _setDefaultRoyalty(msg.sender, uint96(royaltyPercentage));
        
        skillMetadata[tokenId] = SkillMetadata({
            skillId: skillId,
            name: name,
            category: category,
            tags: tags,
            creator: msg.sender,
            createdAt: block.timestamp,
            price: price,
            currency: currency,
            royaltyPercentage: royaltyPercentage,
            isActive: true
        });
        
        skillIdToTokenId[skillId] = tokenId;
        creatorSkills[msg.sender].push(tokenId);
        
        emit SkillCreated(tokenId, skillId, msg.sender);
        return tokenId;
    }
    
    function updateSkillPrice(uint256 tokenId, uint256 newPrice) public {
        require(_exists(tokenId), "Skill does not exist");
        require(ownerOf(tokenId) == msg.sender, "Not skill owner");
        
        skillMetadata[tokenId].price = newPrice;
        emit SkillPriceUpdated(tokenId, newPrice);
    }
    
    function getCreatorSkills(address creator) public view returns (uint256[] memory) {
        return creatorSkills[creator];
    }
    
    function searchSkillsByCategory(string memory category) public view returns (uint256[] memory) {
        uint256[] memory categorySkills = new uint256[](_tokenIdCounter);
        uint256 count = 0;
        
        for (uint256 i = 0; i < _tokenIdCounter; i++) {
            if (skillMetadata[i].isActive && 
                keccak256(bytes(skillMetadata[i].category)) == keccak256(bytes(category))) {
                categorySkills[count] = i;
                count++;
            }
        }
        
        uint256[] memory result = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = categorySkills[i];
        }
        
        return result;
    }
    
    // Override required functions
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage, ERC721Royalty) {
        super._burn(tokenId);
    }
    
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage, ERC721Royalty) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
```

### 4.3 LicenseTokenåˆçº¦
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";

contract LicenseToken is ERC1155, ERC1155Supply, Ownable {
    
    struct LicenseMetadata {
        uint256 skillTokenId;
        address licensee;
        uint256 expiryTime;
        uint256 usageLimit;
        uint256 usageCount;
        bool isActive;
        string licenseType; // "subscription", "one-time", "limited"
    }
    
    mapping(uint256 => LicenseMetadata) public licenseMetadata;
    mapping(address => uint256[]) public userLicenses;
    mapping(uint256 => mapping(address => uint256)) public skillUserLicense;
    
    uint256 private _licenseIdCounter;
    
    event LicenseCreated(uint256 indexed licenseId, address indexed licensee, uint256 skillTokenId);
    event LicenseUsed(uint256 indexed licenseId, address indexed user);
    event LicenseExpired(uint256 indexed licenseId);
    
    constructor() ERC1155("") {}
    
    function createLicense(
        address licensee,
        uint256 skillTokenId,
        uint256 amount,
        uint256 duration,
        uint256 usageLimit,
        string memory licenseType
    ) public returns (uint256) {
        uint256 licenseId = _licenseIdCounter;
        _licenseIdCounter++;
        
        uint256 expiryTime = duration > 0 ? block.timestamp + duration : 0;
        
        licenseMetadata[licenseId] = LicenseMetadata({
            skillTokenId: skillTokenId,
            licensee: licensee,
            expiryTime: expiryTime,
            usageLimit: usageLimit,
            usageCount: 0,
            isActive: true,
            licenseType: licenseType
        });
        
        _mint(licensee, licenseId, amount, "");
        
        userLicenses[licensee].push(licenseId);
        skillUserLicense[skillTokenId][licensee] = licenseId;
        
        emit LicenseCreated(licenseId, licensee, skillTokenId);
        return licenseId;
    }
    
    function useLicense(uint256 licenseId, address user) public {
        require(balanceOf(user, licenseId) > 0, "No license balance");
        
        LicenseMetadata storage license = licenseMetadata[licenseId];
        require(license.isActive, "License not active");
        
        if (license.expiryTime > 0) {
            require(block.timestamp <= license.expiryTime, "License expired");
        }
        
        if (license.usageLimit > 0) {
            require(license.usageCount < license.usageLimit, "Usage limit exceeded");
            license.usageCount++;
        }
        
        emit LicenseUsed(licenseId, user);
    }
    
    function checkLicenseValidity(uint256 licenseId, address user) public view returns (bool) {
        if (balanceOf(user, licenseId) == 0) return false;
        
        LicenseMetadata memory license = licenseMetadata[licenseId];
        if (!license.isActive) return false;
        
        if (license.expiryTime > 0 && block.timestamp > license.expiryTime) return false;
        if (license.usageLimit > 0 && license.usageCount >= license.usageLimit) return false;
        
        return true;
    }
    
    function getUserLicenses(address user) public view returns (uint256[] memory) {
        return userLicenses[user];
    }
    
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override(ERC1155, ERC1155Supply) {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }
}
```

## 5. å‰ç«¯åŠŸèƒ½æ¨¡å—

### 5.1 é¡µé¢ç»“æ„
```mermaid
graph TD
    A[SkillChainå‰ç«¯]
    A --> B[é¦–é¡µ]
    A --> C[å¸‚åœºé¡µé¢]
    A --> D[æŠ€èƒ½è¯¦æƒ…]
    A --> E[ç”¨æˆ·ä¸­å¿ƒ]
    A --> F[åˆ›å»ºæŠ€èƒ½]
    A --> G[ç®¡ç†é¢æ¿]
    
    B --> B1[çƒ­é—¨æŠ€èƒ½]
    B --> B2[åˆ†ç±»æµè§ˆ]
    B --> B3[æœç´¢åŠŸèƒ½]
    B --> B4[ç»Ÿè®¡ä¿¡æ¯]
    
    C --> C1[æŠ€èƒ½åˆ—è¡¨]
    C --> C2[ç­›é€‰æ’åº]
    C --> C3[ä»·æ ¼å›¾è¡¨]
    C --> C4[æ”¶è—å¤¹]
    
    D --> D1[æŠ€èƒ½å±•ç¤º]
    D --> D2[è´­ä¹°/ç§Ÿç”¨]
    D --> D3[è¯„ä»·ç³»ç»Ÿ]
    D --> D4[ä½¿ç”¨ç¤ºä¾‹]
    
    E --> E1[æˆ‘çš„æŠ€èƒ½]
    E --> E2[è®¸å¯è¯ç®¡ç†]
    E --> E3[æ”¶ç›Šç»Ÿè®¡]
    E --> E4[ä¿¡èª‰åˆ†æ•°]
    
    F --> F1[æŠ€èƒ½ä¸Šä¼ ]
    F --> F2[å…ƒæ•°æ®ç¼–è¾‘]
    F --> F3[å®šä»·è®¾ç½®]
    F --> F4[é¢„è§ˆæµ‹è¯•]
    
    G --> G1[æŠ€èƒ½å®¡æ ¸]
    G --> G2[äº‰è®®å¤„ç†]
    G --> G3[å¹³å°è®¾ç½®]
    G --> G4[æ•°æ®åˆ†æ]
```

### 5.2 æ ¸å¿ƒç»„ä»¶

#### æŠ€èƒ½å¡ç‰‡ç»„ä»¶
```tsx
// components/skill-card.tsx
import { Skill } from "~~/types/skill";
import { Address } from "~~/components/scaffold-eth";

interface SkillCardProps {
  skill: Skill;
  onPurchase: (skillId: string) => void;
  onRent: (skillId: string) => void;
}

export function SkillCard({ skill, onPurchase, onRent }: SkillCardProps) {
  return (
    <div className="card bg-base-100 shadow-xl hover:shadow-2xl transition-shadow">
      <figure className="px-4 pt-4">
        <div className="w-full h-48 bg-gradient-to-br from-primary to-secondary rounded-lg flex items-center justify-center">
          <span className="text-4xl">{skill.icon || "ğŸ¯"}</span>
        </div>
      </figure>
      <div className="card-body">
        <h2 className="card-title">{skill.name}</h2>
        <p className="text-sm text-base-content/70">{skill.description}</p>
        
        <div className="flex items-center gap-2 mt-2">
          <Address address={skill.creator} format="short" />
          <div className="badge badge-primary">{skill.category}</div>
        </div>
        
        <div className="flex items-center justify-between mt-4">
          <div className="flex items-center gap-1">
            <span className="text-lg font-bold">{skill.price}</span>
            <span className="text-sm text-base-content/70">{skill.currency}</span>
          </div>
          <div className="flex items-center gap-1">
            <span className="text-yellow-500">â­</span>
            <span className="text-sm">{skill.rating}</span>
          </div>
        </div>
        
        <div className="card-actions justify-end mt-4">
          <button 
            className="btn btn-primary btn-sm"
            onClick={() => onPurchase(skill.id)}
          >
            è´­ä¹°
          </button>
          <button 
            className="btn btn-outline btn-primary btn-sm"
            onClick={() => onRent(skill.id)}
          >
            ç§Ÿç”¨
          </button>
        </div>
      </div>
    </div>
  );
}
```

#### æŠ€èƒ½åˆ›å»ºå‘å¯¼
```tsx
// components/create-skill-wizard.tsx
import { useState } from "react";
import { useScaffoldWriteContract } from "~~/hooks/scaffold-eth";

interface SkillFormData {
  name: string;
  description: string;
  category: string;
  tags: string[];
  price: string;
  currency: string;
  royalty: number;
  aiModels: string[];
  requirements: {
    contextWindow: string;
    tools: string[];
  };
}

export function CreateSkillWizard() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState<SkillFormData>({
    name: "",
    description: "",
    category: "",
    tags: [],
    price: "0.1",
    currency: "ETH",
    royalty: 5,
    aiModels: [],
    requirements: {
      contextWindow: "8k",
      tools: []
    }
  });
  
  const { writeContractAsync: createSkill } = useScaffoldWriteContract("SkillNFT");
  
  const handleSubmit = async () => {
    try {
      // 1. ä¸Šä¼ æŠ€èƒ½æ–‡ä»¶åˆ°IPFS
      const skillId = generateSkillId(formData.name);
      const metadata = {
        ...formData,
        createdAt: new Date().toISOString(),
        version: "1.0.0"
      };
      
      const ipfsHash = await uploadToIPFS(metadata);
      
      // 2. åˆ›å»ºNFT
      await createSkill({
        functionName: "createSkill",
        args: [
          skillId,
          formData.name,
          formData.category,
          formData.tags,
          `ipfs://${ipfsHash}`,
          parseEther(formData.price),
          formData.currency,
          formData.royalty * 100 // è½¬æ¢ä¸ºåŸºç‚¹
        ]
      });
      
      alert("æŠ€èƒ½åˆ›å»ºæˆåŠŸï¼");
    } catch (error) {
      console.error("åˆ›å»ºæŠ€èƒ½å¤±è´¥:", error);
      alert("åˆ›å»ºå¤±è´¥ï¼Œè¯·é‡è¯•");
    }
  };
  
  return (
    <div className="container mx-auto p-6">
      <div className="steps">
        <ul className="steps steps-horizontal">
          <li className={`step ${step >= 1 ? "step-primary" : ""}`}>åŸºæœ¬ä¿¡æ¯</li>
          <li className={`step ${step >= 2 ? "step-primary" : ""}`}>æŠ€èƒ½é…ç½®</li>
          <li className={`step ${step >= 3 ? "step-primary" : ""}`}>å®šä»·è®¾ç½®</li>
          <li className={`step ${step >= 4 ? "step-primary" : ""}`}>æ–‡ä»¶ä¸Šä¼ </li>
        </ul>
      </div>
      
      <div className="mt-8">
        {step === 1 && <BasicInfoStep data={formData} onChange={setFormData} />}
        {step === 2 && <SkillConfigStep data={formData} onChange={setFormData} />}
        {step === 3 && <PricingStep data={formData} onChange={setFormData} />}
        {step === 4 && <FileUploadStep data={formData} onSubmit={handleSubmit} />}
      </div>
      
      <div className="flex justify-between mt-8">
        <button 
          className="btn btn-outline"
          onClick={() => setStep(Math.max(1, step - 1))}
          disabled={step === 1}
        >
          ä¸Šä¸€æ­¥
        </button>
        <button 
          className="btn btn-primary"
          onClick={() => setStep(Math.min(4, step + 1))}
          disabled={step === 4}
        >
          ä¸‹ä¸€æ­¥
        </button>
      </div>
    </div>
  );
}
```

## 6. é“¾ä¸Šé“¾ä¸‹æ•°æ®æµ

### 6.1 æ•°æ®æµæ¶æ„
```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant Supabase
    participant IPFS
    participant SmartContract
    participant Ethereum
    
    User->>Frontend: åˆ›å»ºæŠ€èƒ½
    Frontend->>Supabase: éªŒè¯ç”¨æˆ·èº«ä»½
    Supabase-->>Frontend: è¿”å›éªŒè¯ç»“æœ
    Frontend->>IPFS: ä¸Šä¼ æŠ€èƒ½æ–‡ä»¶
    IPFS-->>Frontend: è¿”å›IPFSå“ˆå¸Œ
    Frontend->>SmartContract: è°ƒç”¨createSkill
    SmartContract->>Ethereum: éƒ¨ç½²NFTåˆçº¦
    Ethereum-->>SmartContract: ç¡®è®¤äº¤æ˜“
    SmartContract-->>Frontend: è¿”å›tokenId
    Frontend->>Supabase: å­˜å‚¨æŠ€èƒ½å…ƒæ•°æ®
    Supabase-->>Frontend: ç¡®è®¤å­˜å‚¨
    Frontend-->>User: æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
```

### 6.2 æ•°æ®åŒæ­¥æœºåˆ¶

#### å®æ—¶åŒæ­¥
```typescript
// hooks/useSkillSync.ts
import { useScaffoldEventHistory } from "~~/hooks/scaffold-eth";
import { useEffect, useState } from "react";

export function useSkillSync() {
  const [skills, setSkills] = useState([]);
  const [loading, setLoading] = useState(true);
  
  // ç›‘å¬é“¾ä¸Šäº‹ä»¶
  const { data: events, isLoading } = useScaffoldEventHistory({
    contractName: "SkillNFT",
    eventName: "SkillCreated",
    fromBlock: 0n,
  });
  
  useEffect(() => {
    if (!isLoading && events) {
      syncSkillsWithDatabase(events);
    }
  }, [events, isLoading]);
  
  const syncSkillsWithDatabase = async (chainEvents: any[]) => {
    try {
      // 1. è·å–é“¾ä¸ŠæŠ€èƒ½æ•°æ®
      const chainSkills = await Promise.all(
        chainEvents.map(async (event) => {
          const tokenId = event.args.tokenId;
          const metadata = await readContract({
            contractName: "SkillNFT",
            functionName: "skillMetadata",
            args: [tokenId]
          });
          return { tokenId, ...metadata };
        })
      );
      
      // 2. ä¸æ•°æ®åº“åŒæ­¥
      const response = await fetch("/api/sync-skills", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ skills: chainSkills })
      });
      
      if (response.ok) {
        const syncedSkills = await response.json();
        setSkills(syncedSkills);
      }
      
      setLoading(false);
    } catch (error) {
      console.error("æŠ€èƒ½åŒæ­¥å¤±è´¥:", error);
      setLoading(false);
    }
  };
  
  return { skills, loading, refetch: syncSkillsWithDatabase };
}
```

## 7. ç»æµæ¨¡å‹å’Œæ”¶ç›Šåˆ†é…æœºåˆ¶

### 7.1 ç»æµæ¨¡å‹è®¾è®¡
```mermaid
graph TD
    A[SKILLä»£å¸]
    A --> B[æŠ€èƒ½è´­ä¹°]
    A --> C[è®¸å¯è¯ç§Ÿç”¨]
    A --> D[è´¨æŠ¼æŒ–çŸ¿]
    A --> E[æ²»ç†æŠ•ç¥¨]
    
    B --> F[åˆ›ä½œè€…æ”¶ç›Š]
    B --> G[å¹³å°è´¹ç”¨]
    B --> H[æ¨èå¥–åŠ±]
    
    C --> I[æŒ‰æ—¶è®¡è´¹]
    C --> J[æŒ‰æ¬¡è®¡è´¹]
    C --> K[åŒ…æœˆè®¢é˜…]
    
    D --> L[æµåŠ¨æ€§å¥–åŠ±]
    D --> M[è´¨æŠ¼åˆ©æ¯]
    
    E --> N[å‚æ•°è°ƒæ•´]
    E --> O[å¹³å°å‡çº§]
```

### 7.2 æ”¶ç›Šåˆ†é…åˆçº¦
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract RevenueDistributor is Ownable {
    
    struct RevenueShare {
        address creator;
        uint256 creatorShare; // åŸºç‚¹ (10000 = 100%)
        address platform;
        uint256 platformShare;
        address[] affiliates;
        uint256[] affiliateShares;
    }
    
    struct Transaction {
        uint256 amount;
        address payer;
        uint256 timestamp;
        RevenueShare shares;
    }
    
    mapping(uint256 => Transaction[]) public skillTransactions;
    mapping(address => uint256) public pendingWithdrawals;
    mapping(address => uint256) public totalEarned;
    
    uint256 public platformFee = 250; // 2.5%
    uint256 public affiliateReward = 100; // 1%
    
    event RevenueDistributed(
        uint256 indexed skillId,
        uint256 amount,
        address indexed creator,
        address indexed platform
    );
    
    event Withdrawal(address indexed recipient, uint256 amount);
    
    constructor() {}
    
    function distributeRevenue(
        uint256 skillId,
        uint256 amount,
        address creator,
        address[] memory affiliates
    ) external payable {
        require(amount > 0, "Amount must be positive");
        
        // è®¡ç®—åˆ†é…æ¯”ä¾‹
        uint256 creatorShare = amount * (10000 - platformFee - affiliateReward) / 10000;
        uint256 platformShare = amount * platformFee / 10000;
        uint256 totalAffiliateShare = amount * affiliateReward / 10000;
        
        // å¤„ç†æ¨èäººå¥–åŠ±
        uint256[] memory affiliateShares = new uint256[](affiliates.length);
        if (affiliates.length > 0) {
            uint256 sharePerAffiliate = totalAffiliateShare / affiliates.length;
            for (uint256 i = 0; i < affiliates.length; i++) {
                affiliateShares[i] = sharePerAffiliate;
                pendingWithdrawals[affiliates[i]] += sharePerAffiliate;
            }
        }
        
        // æ›´æ–°å¾…æå–é‡‘é¢
        pendingWithdrawals[creator] += creatorShare;
        pendingWithdrawals[owner()] += platformShare;
        
        // è®°å½•äº¤æ˜“
        RevenueShare memory shares = RevenueShare({
            creator: creator,
            creatorShare: creatorShare,
            platform: owner(),
            platformShare: platformShare,
            affiliates: affiliates,
            affiliateShares: affiliateShares
        });
        
        skillTransactions[skillId].push(Transaction({
            amount: amount,
            payer: msg.sender,
            timestamp: block.timestamp,
            shares: shares
        }));
        
        emit RevenueDistributed(skillId, amount, creator, owner());
    }
    
    function withdraw() external {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount > 0, "No pending withdrawal");
        
        pendingWithdrawals[msg.sender] = 0;
        totalEarned[msg.sender] += amount;
        
        // è½¬è´¦ETH
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "Transfer failed");
        
        emit Withdrawal(msg.sender, amount);
    }
    
    function getPendingWithdrawal(address account) external view returns (uint256) {
        return pendingWithdrawals[account];
    }
    
    function getTotalEarned(address account) external view returns (uint256) {
        return totalEarned[account];
    }
    
    function updatePlatformFee(uint256 newFee) external onlyOwner {
        require(newFee <= 1000, "Fee too high"); // Max 10%
        platformFee = newFee;
    }
    
    function updateAffiliateReward(uint256 newReward) external onlyOwner {
        require(newReward <= 500, "Reward too high"); // Max 5%
        affiliateReward = newReward;
    }
}
```

## 8. ä¿¡èª‰ç³»ç»Ÿå®ç°

### 8.1 ä¿¡èª‰è¯„åˆ†ç®—æ³•
```typescript
// utils/reputation.ts
export interface ReputationFactors {
  skillQuality: number;      // æŠ€èƒ½è´¨é‡è¯„åˆ† (1-5)
  transactionVolume: number; // äº¤æ˜“æ•°é‡
  successfulTransactions: number; // æˆåŠŸäº¤æ˜“æ•°
  disputeCount: number;      // äº‰è®®æ¬¡æ•°
  responseTime: number;       // å“åº”æ—¶é—´ (å°æ—¶)
  userReviews: Review[];     // ç”¨æˆ·è¯„ä»·
  platformContribution: number; // å¹³å°è´¡çŒ®åº¦
  stakingAmount: number;     // è´¨æŠ¼æ•°é‡
}

export interface Review {
  reviewer: string;
  rating: number;
  comment: string;
  timestamp: number;
  verified: boolean;
}

export class ReputationCalculator {
  private static readonly WEIGHTS = {
    skillQuality: 0.25,
    transactionReliability: 0.20,
    userSatisfaction: 0.20,
    platformContribution: 0.15,
    stakingCommitment: 0.10,
    responseEfficiency: 0.10
  };

  static calculateReputation(factors: ReputationFactors): number {
    const skillScore = this.calculateSkillScore(factors);
    const transactionScore = this.calculateTransactionScore(factors);
    const satisfactionScore = this.calculateSatisfactionScore(factors);
    const contributionScore = this.calculateContributionScore(factors);
    const stakingScore = this.calculateStakingScore(factors);
    const responseScore = this.calculateResponseScore(factors);

    const totalScore = 
      skillScore * this.WEIGHTS.skillQuality +
      transactionScore * this.WEIGHTS.transactionReliability +
      satisfactionScore * this.WEIGHTS.userSatisfaction +
      contributionScore * this.WEIGHTS.platformContribution +
      stakingScore * this.WEIGHTS.stakingCommitment +
      responseScore * this.WEIGHTS.responseEfficiency;

    return Math.min(100, Math.max(0, totalScore));
  }

  private static calculateSkillScore(factors: ReputationFactors): number {
    const baseScore = factors.skillQuality;
    const reviewScore = this.calculateAverageRating(factors.userReviews);
    return (baseScore + reviewScore) / 2 * 20; // è½¬æ¢ä¸º0-100
  }

  private static calculateTransactionScore(factors: ReputationFactors): number {
    if (factors.transactionVolume === 0) return 0;
    
    const successRate = factors.successfulTransactions / factors.transactionVolume;
    const volumeBonus = Math.min(10, factors.transactionVolume / 10); // äº¤æ˜“é‡å¥–åŠ±
    
    return Math.min(100, successRate * 90 + volumeBonus);
  }

  private static calculateSatisfactionScore(factors: ReputationFactors): number {
    if (factors.userReviews.length === 0) return 50;
    
    const avgRating = this.calculateAverageRating(factors.userReviews);
    const verifiedReviews = factors.userReviews.filter(r => r.verified).length;
    const verificationBonus = (verifiedReviews / factors.userReviews.length) * 10;
    
    return avgRating * 20 + verificationBonus;
  }

  private static calculateContributionScore(factors: ReputationFactors): number {
    // åŸºäºå¹³å°è´¡çŒ®åº¦çš„è¯„åˆ†
    return Math.min(100, factors.platformContribution * 10);
  }

  private static calculateStakingScore(factors: ReputationFactors): number {
    // è´¨æŠ¼æ•°é‡è¯„åˆ†ï¼Œå‡è®¾æœ€å¤§è´¨æŠ¼1000ä»£å¸
    const maxStaking = 1000;
    return Math.min(100, (factors.stakingAmount / maxStaking) * 100);
  }

  private static calculateResponseScore(factors: ReputationFactors): number {
    // å“åº”æ—¶é—´è¯„åˆ†ï¼Œ24å°æ—¶å†…ä¸ºæ»¡åˆ†
    const idealResponseTime = 24;
    const responseScore = Math.max(0, 100 - (factors.responseTime - idealResponseTime) * 2);
    return Math.max(0, responseScore);
  }

  private static calculateAverageRating(reviews: Review[]): number {
    if (reviews.length === 0) return 0;
    const sum = reviews.reduce((acc, review) => acc + review.rating, 0);
    return sum / reviews.length;
  }
}
```

### 8.2 ä¿¡èª‰ç®¡ç†åˆçº¦
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/access/Ownable.sol";

contract ReputationManager is Ownable {
    
    struct ReputationData {
        uint256 totalScore;
        uint256 transactionCount;
        uint256 successfulTransactions;
        uint256 disputeCount;
        uint256 lastUpdated;
        uint256 reviewCount;
        uint256 totalRating;
        bool isVerified;
    }
    
    mapping(address => ReputationData) public userReputation;
    mapping(address => mapping(address => bool)) public hasReviewed;
    
    uint256 public constant MAX_REPUTATION = 1000;
    uint256 public constant MIN_REPUTATION_FOR_VERIFICATION = 700;
    
    event ReputationUpdated(address indexed user, uint256 newScore);
    event UserVerified(address indexed user);
    event ReviewSubmitted(address indexed reviewer, address indexed target, uint256 rating);
    
    constructor() {}
    
    function updateReputation(
        address user,
        uint256 skillQuality,
        uint256 transactionVolume,
        uint256 successfulTransactions,
        uint256 disputeCount,
        uint256 responseTime
    ) external {
        ReputationData storage reputation = userReputation[user];
        
        // æ›´æ–°åŸºç¡€æ•°æ®
        reputation.transactionCount += transactionVolume;
        reputation.successfulTransactions += successfulTransactions;
        reputation.disputeCount += disputeCount;
        reputation.lastUpdated = block.timestamp;
        
        // è®¡ç®—æ–°çš„ä¿¡èª‰åˆ†æ•°
        uint256 newScore = calculateReputationScore(
            skillQuality,
            reputation.transactionCount,
            reputation.successfulTransactions,
            reputation.disputeCount,
            responseTime,
            reputation.reviewCount,
            reputation.totalRating
        );
        
        reputation.totalScore = newScore;
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°éªŒè¯æ ‡å‡†
        if (!reputation.isVerified && newScore >= MIN_REPUTATION_FOR_VERIFICATION) {
            reputation.isVerified = true;
            emit UserVerified(user);
        }
        
        emit ReputationUpdated(user, newScore);
    }
    
    function submitReview(
        address target,
        uint256 rating,
        string memory comment
    ) external {
        require(rating >= 1 && rating <= 5, "Invalid rating");
        require(!hasReviewed[msg.sender][target], "Already reviewed");
        
        ReputationData storage reputation = userReputation[target];
        reputation.reviewCount++;
        reputation.totalRating += rating;
        hasReviewed[msg.sender][target] = true;
        
        // é‡æ–°è®¡ç®—ä¿¡èª‰åˆ†æ•°
        uint256 newScore = calculateReputationScore(
            0, // skillQuality ä¸æ›´æ–°
            reputation.transactionCount,
            reputation.successfulTransactions,
            reputation.disputeCount,
            0, // responseTime ä¸æ›´æ–°
            reputation.reviewCount,
            reputation.totalRating
        );
        
        reputation.totalScore = newScore;
        
        emit ReviewSubmitted(msg.sender, target, rating);
        emit ReputationUpdated(target, newScore);
    }
    
    function calculateReputationScore(
        uint256 skillQuality,
        uint256 transactionCount,
        uint256 successfulTransactions,
        uint256 disputeCount,
        uint256 responseTime,
        uint256 reviewCount,
        uint256 totalRating
    ) internal pure returns (uint256) {
        // åŸºç¡€åˆ†æ•°
        uint256 baseScore = 500;
        
        // æŠ€èƒ½è´¨é‡åˆ†æ•° (0-200)
        uint256 skillScore = skillQuality * 40;
        
        // äº¤æ˜“å¯é æ€§åˆ†æ•° (0-200)
        uint256 transactionScore = 0;
        if (transactionCount > 0) {
            uint256 successRate = (successfulTransactions * 100) / transactionCount;
            transactionScore = successRate * 2;
        }
        
        // ç”¨æˆ·æ»¡æ„åº¦åˆ†æ•° (0-100)
        uint256 satisfactionScore = 0;
        if (reviewCount > 0) {
            uint256 avgRating = totalRating / reviewCount;
            satisfactionScore = avgRating * 20;
        }
        
        // äº‰è®®æƒ©ç½š (-100 to 0)
        uint256 disputePenalty = 0;
        if (transactionCount > 0) {
            uint256 disputeRate = (disputeCount * 100) / transactionCount;
            disputePenalty = disputeRate > 10 ? 100 : disputeRate * 10;
        }
        
        uint256 totalScore = baseScore + skillScore + transactionScore + satisfactionScore - disputePenalty;
        return Math.min(MAX_REPUTATION, totalScore);
    }
    
    function getUserReputation(address user) external view returns (
        uint256 totalScore,
        uint256 transactionCount,
        uint256 successfulTransactions,
        uint256 disputeCount,
        bool isVerified
    ) {
        ReputationData memory reputation = userReputation[user];
        return (
            reputation.totalScore,
            reputation.transactionCount,
            reputation.successfulTransactions,
            reputation.disputeCount,
            reputation.isVerified
        );
    }
    
    function isUserVerified(address user) external view returns (bool) {
        return userReputation[user].isVerified;
    }
}
```

## 9. å¼€å‘è·¯çº¿å›¾å’Œé‡Œç¨‹ç¢‘

### 9.1 ç¬¬ä¸€é˜¶æ®µï¼šMVPå¼€å‘ï¼ˆ1-2ä¸ªæœˆï¼‰
- âœ… åŸºç¡€æ™ºèƒ½åˆçº¦å¼€å‘
- âœ… å‰ç«¯æ¡†æ¶æ­å»º
- âœ… ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
- âœ… æŠ€èƒ½ä¸Šä¼ å’Œå±•ç¤º
- âœ… åŸºç¡€è´­ä¹°/ç§Ÿç”¨åŠŸèƒ½

### 9.2 ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒåŠŸèƒ½ï¼ˆ2-3ä¸ªæœˆï¼‰
- ğŸ”„ é«˜çº§æœç´¢å’Œæ¨è
- ğŸ”„ å®Œæ•´çš„ç»æµæ¨¡å‹
- ğŸ”„ ä¿¡èª‰ç³»ç»Ÿ
- ğŸ”„ å¤šé“¾æ”¯æŒ
- ğŸ”„ ç§»åŠ¨ç«¯é€‚é…

### 9.3 ç¬¬ä¸‰é˜¶æ®µï¼šç”Ÿæ€ç³»ç»Ÿï¼ˆ3-4ä¸ªæœˆï¼‰
- ğŸ“‹ AIæŠ€èƒ½éªŒè¯å™¨
- ğŸ“‹ æ‰¹é‡æ“ä½œå·¥å…·
- ğŸ“‹ ä¼ä¸šçº§API
- ğŸ“‹ ç¤¾åŒºæ²»ç†
- ğŸ“‹ è·¨å¹³å°SDK

### 9.4 ç¬¬å››é˜¶æ®µï¼šæ‰©å±•åŠŸèƒ½ï¼ˆ4-6ä¸ªæœˆï¼‰
- ğŸ“‹ æŠ€èƒ½ç»„åˆå¸‚åœº
- ğŸ“‹ è®¢é˜…æœåŠ¡æ¨¡å¼
- ğŸ“‹ ç™½æ ‡è§£å†³æ–¹æ¡ˆ
- ğŸ“‹ å…¨çƒåˆè§„æ¡†æ¶
- ğŸ“‹ DAOæ²»ç†

### 9.5 æŠ€æœ¯é‡Œç¨‹ç¢‘
```mermaid
gantt
    title SkillChainå¼€å‘è·¯çº¿å›¾
    dateFormat  YYYY-MM-DD
    section æ™ºèƒ½åˆçº¦
    åŸºç¡€åˆçº¦å¼€å‘           :done,    des1, 2024-01-01,2024-01-15
    NFT/è®¸å¯è¯åˆçº¦        :done,    des2, 2024-01-16,2024-01-30
    æ”¶ç›Šåˆ†é…åˆçº¦          :done,    des3, 2024-02-01,2024-02-15
    ä¿¡èª‰ç³»ç»Ÿåˆçº¦          :active,  des4, 2024-02-16,2024-03-01
    
    section å‰ç«¯å¼€å‘
    æ¡†æ¶æ­å»º              :done,    des5, 2024-01-01,2024-01-10
    UIç»„ä»¶å¼€å‘            :done,    des6, 2024-01-11,2024-01-25
    æ ¸å¿ƒåŠŸèƒ½å®ç°          :active,  des7, 2024-01-26,2024-02-20
    ç§»åŠ¨ç«¯é€‚é…            :des8, 2024-02-21,2024-03-10
    
    section åç«¯æœåŠ¡
    Supabaseé›†æˆ          :done,    des9, 2024-01-05,2024-01-15
    IPFSå­˜å‚¨ç³»ç»Ÿ          :done,    des10, 2024-01-16,2024-01-25
    é“¾ä¸‹è®¡ç®—æœåŠ¡          :active,  des11, 2024-01-26,2024-02-15
    APIç½‘å…³å¼€å‘           :des12, 2024-02-16,2024-03-01
    
    section AIé›†æˆ
    Claude Skillsè§£æ     :active,  des13, 2024-02-01,2024-02-20
    æŠ€èƒ½éªŒè¯å™¨            :des14, 2024-02-21,2024-03-10
    å¤šAIæ¨¡å‹æ”¯æŒ          :des15, 2024-03-11,2024-04-01
```

## 10. é£é™©æ§åˆ¶å’Œåˆè§„

### 10.1 æŠ€æœ¯é£é™©
- **æ™ºèƒ½åˆçº¦å®‰å…¨**ï¼šå¤šé‡å®¡è®¡ + å½¢å¼åŒ–éªŒè¯
- **æ•°æ®éšç§**ï¼šé›¶çŸ¥è¯†è¯æ˜ + åŒæ€åŠ å¯†
- **ç³»ç»Ÿå¯ç”¨æ€§**ï¼šåˆ†å¸ƒå¼æ¶æ„ + æ•…éšœè½¬ç§»

### 10.2 æ³•å¾‹åˆè§„
- **KYC/AML**ï¼šé›†æˆåˆè§„æœåŠ¡æä¾›å•†
- **çŸ¥è¯†äº§æƒ**ï¼šDMCAæµç¨‹ + äº‰è®®è§£å†³
- **ç¨åŠ¡åˆè§„**ï¼šè‡ªåŠ¨ç¨åŠ¡æŠ¥å‘Šç”Ÿæˆ

### 10.3 ç»æµå®‰å…¨
- **ä»·æ ¼æ“çºµé˜²æŠ¤**ï¼šæ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼
- **é—ªç”µè´·æ”»å‡»**ï¼šé‡å…¥ä¿æŠ¤ + æ£€æŸ¥-ç”Ÿæ•ˆ-äº¤äº’
- **æµåŠ¨æ€§é£é™©**ï¼šå¤šDEXé›†æˆ + ä¿é™©åŸºé‡‘

---

è¿™ä»½å¼€å‘æ–‡æ¡£ä¸ºSkillChainé¡¹ç›®æä¾›äº†å®Œæ•´çš„æŠ€æœ¯å®ç°æ–¹æ¡ˆï¼Œç»“åˆäº†æœ€æ–°çš„Claude Skillså‘å±•è¶‹åŠ¿å’ŒåŒºå—é“¾æŠ€æœ¯æœ€ä½³å®è·µã€‚æ–‡æ¡£æ¶µç›–äº†ä»æ¶æ„è®¾è®¡åˆ°å…·ä½“å®ç°çš„å„ä¸ªæ–¹é¢ï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›äº†æ¸…æ™°çš„å¼€å‘æŒ‡å¯¼ã€‚

éœ€è¦æˆ‘è¯¦ç»†è§£é‡Šä»»ä½•ç‰¹å®šéƒ¨åˆ†ï¼Œæˆ–è€…æ ¹æ®ä½ çš„å…·ä½“éœ€æ±‚è¿›è¡Œè°ƒæ•´å—ï¼Ÿ